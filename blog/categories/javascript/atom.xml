<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | Kamranicus]]></title>
  <link href="http://kamranicus.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://kamranicus.com/"/>
  <updated>2015-05-22T13:56:12+00:00</updated>
  <id>http://kamranicus.com/</id>
  <author>
    <name><![CDATA[Kamran]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Extending Knockout Observables to Sync With Address Bar]]></title>
    <link href="http://kamranicus.com/blog/2015/05/11/extending-knockout-with-urlsync/"/>
    <updated>2015-05-11T16:20:00+00:00</updated>
    <id>http://kamranicus.com/blog/2015/05/11/extending-knockout-with-urlsync</id>
    <content type="html"><![CDATA[<p>I made a tiny Knockout extender called <code>urlSync</code> that syncs an observable with the URL.</p>

<!-- More -->


<p>For <a href="http://keeptrackofmygames.com">Keep Track of My Games</a> I&rsquo;ve been adding filtering to the game library.
I&rsquo;m really proud of what I have, here&rsquo;s what it looks like in the UI:</p>

<p><img src="/blog/images/2015-05-11-filtering.png" alt="Filtering UI" /></p>

<p>A modal allows the user to drill down and pick what filters to apply, the modal updates to show what filters are applied and what&rsquo;s available with the current resultset.</p>

<p><img src="/blog/images/2015-05-11-filtering-modal.png" alt="Filtering Modal" /></p>

<p>When you&rsquo;re outside the modal, I show any filters being applied allowing one-click removal or toggling the filtering method between AND/OR.</p>

<p>To make it easy to serialize/deserialize filters, I created a custom filtering expression that is pretty standard around town:</p>

<pre><code>{facetName}:{facetValue},{facetValue},...|...
</code></pre>

<p>For example, representing the screenshot above, the filtering expression would be:</p>

<pre><code>Lists:6|Status:8|My+Platforms:1
</code></pre>

<p>If you muck with the expression, there shouldn&rsquo;t be any issues. Facets are validated against whatever the original unfiltered resultset is, so you cannot add arbitrary expressions&mdash;if you do, they will not show up in the server response. Strings are special because potentially they can include characters used to parse the expression, the simplest way to deal with it is by encoding them and then decoding the value.</p>

<pre><code>Tags:my%20awesome%2ctag,tag2|Status:4
</code></pre>

<p>Now, I wanted to talk about the filtering expression because it makes it really easy to do a bunch of things:</p>

<ol>
<li>Reading/writing from querystring or hash</li>
<li>Create a command textbox that can parse and autocomplete expressions</li>
<li>Allow the user to save &ldquo;views&rdquo; of their games</li>
</ol>


<p>Items 2 and 3 might be on the agenda for some later date but item 1 is required for being able to create pre-filtered routes or create links. Since the library is loaded through Knockout and Web API, we need to be able to pass any filter or parameters when the page is loaded and also keep track of what the current values are for filtering.</p>

<p>To achieve this, I created a really simple <a href="http://knockoutjs.com/documentation/extenders.html">Knockout Extender</a> called <strong>urlSync.</strong> All it does is initially load an observable from the hash (if found) or the querystring (if found). Then it observes the observable and keeps the <code>window.location.hash</code> updated.</p>

<p>This could easily be extended to use <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Manipulating_the_browser_history">HTML5 <code>pushState</code></a>, if you wished. For now, managing the hash is &ldquo;good enough&rdquo; for my use case.</p>

<p>Here is a Gist of the extender:</p>

<script src="https://gist.github.com/kamranayub/3feba45dd2da3262b872.js"></script>


<p>It depends on <a href="http://medialize.github.io/URI.js">URI.js</a> and the <a href="http://medialize.github.io/URI.js/docs.html#fragment-abuse">URI.fragmentQuery</a> component. It also uses <a href="http://underscorejs.org">Underscore.js</a>, but that&rsquo;s just because I have it in my project already.</p>

<p>It&rsquo;s really simple to use, for example here&rsquo;s a snippet from my collection view model:</p>

<p>```
// Flattened facets
ViewModel.facets = ko.observableArray([]);</p>

<p>// Selected (applied) facets
ViewModel.selectedFacets = ko.observableArray([]).extend({</p>

<pre><code>urlSync: {
    param: "filterBy",
    read: function(value) {
       return kt.utils.facetsFromString(value, ViewModel.facets);
    },
    write: kt.utils.facetsToString
}
</code></pre>

<p>});</p>

<p>// Filter AND toggle
ViewModel.filterAnd = ko.observable(false).extend({ urlSync: &ldquo;filterAnd&rdquo; });
```</p>

<p>As you can see, the extender allows you to intercept read/write so you can perform any custom transformations (e.g. filtering objects to/from string). Because we&rsquo;re deserializing from a string and because the <code>checkedValue</code> binding is by reference, I pass in the existing facets collection to my utility, in order to preserve object references when required. On initial page load, this isn&rsquo;t required as the games haven&rsquo;t been fetched from the API yet. Once they are, my fetch method updates the observables. I could also modify the way I handle binding the checkboxes but this works.</p>

<p>The <code>urlSync</code> extender will then bind the observable values to the URL like this:</p>

<pre><code>users/kamran.ayub/lists/all#?
    sortBy=Name&amp;
    filterAnd=true&amp;
    filterBy=Status%3A8%7CLists%3A6%7CMy+Platforms%3A1
</code></pre>

<p>Since the extender can also fallback to reading from the querystring, we can create URLs that filter a user&rsquo;s collection:</p>

<pre><code>users/somebody/lists/all?filterBy=Platforms:2,5,40
</code></pre>

<p>Pretty neat and now allows anyone to copy/paste the URL and preserve any needed filtering state!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Triggering a Travis Build Programmatically]]></title>
    <link href="http://kamranicus.com/blog/2015/03/29/triggering-a-travis-build-programmatically/"/>
    <updated>2015-03-29T22:45:30+00:00</updated>
    <id>http://kamranicus.com/blog/2015/03/29/triggering-a-travis-build-programmatically</id>
    <content type="html"><![CDATA[<p>For <a href="http://excaliburjs.com">Exalibur.js</a> we wanted to be able to keep our <code>master</code> branch documentation up-to-date on the website. The website is built using <a href="http://assemble.io">Assemble.io</a> and GitHub pages and <a href="http://kamranicus.com/blog/2015/02/26/continuous-deployment-with-travis-ci/">after successfully automating my blog</a>, naturally I turned to <a href="http://travis-ci.org">Travis CI</a> to set up automated documentation generation.</p>

<!-- More -->


<p>Travis normally sets up a hook in your GitHub repository to automatically trigger a build after you push a commit (or pull request). This is real nice but unfortunately that&rsquo;s where it stops. If you want to trigger a build <strong>for another repository</strong>, you have to do it manually.</p>

<p>I asked Travis about this and their response is promising (Twitter can be nice sometimes):</p>

<blockquote class="twitter-tweet" data-partner="tweetdeck"><p><a href="https://twitter.com/kamranayub">@kamranayub</a> it&#39;s on the roadmap, and hopefully landing soon &lt;3</p>&mdash; Travis CI (@travisci) <a href="https://twitter.com/travisci/status/582311038772723713">March 29, 2015</a></blockquote>


<script async src="http://kamranicus.com//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>Until that time, though, something has to be done.</p>

<p>One approach I saw was a <a href="https://github.com/metaodi/travis-ping">small Ruby script</a> to forge a webhook POST message. This is actually a nice idea but since Excalibur uses Node to build, I needed something else and didn&rsquo;t want to port it over.</p>

<p>Instead I borrowed some code from <a href="https://github.com/patrickkettner/travis-ping">@patrickketner</a> that uses the <a href="https://github.com/pwmckenna/node-travis-ci">node-travis-ci</a> npm package to submit a build through the public API. I modified Patrick&rsquo;s code since I need to use GitHub personal access tokens like I did <a href="http://kamranicus.com/blog/2015/02/26/continuous-deployment-with-travis-ci/">previously</a>.</p>

<p>You still need to follow the same steps to set up the <code>GH_TOKEN</code> environment variable but once you do, all you have to do is execute this Node.js script (changing the <code>repo</code>).</p>

<script src="https://gist.github.com/kamranayub/88f963a9ac3d5bf6114d.js"></script>


<p>So for example, in your <code>.travis.yml</code> file, you just need:</p>

<p><code>
install:
  - npm install travis-ci
after_success:
  - node trigger-build.js
</code></p>

<p>All set. Now when you commit to one repository, you can trigger a build for another one. This allows us to automatically <a href="http://excaliburjs.com/docs/api/edge">keep our docs up-to-date</a> with whatever <code>master</code> has.</p>

<p>You can <a href="https://github.com/excaliburjs/Excalibur/blob/master/deploy-docs.js">reference Excalibur</a> to see how we execute the script. Additionally, you can reference <a href="https://github.com/excaliburjs/excaliburjs.github.io/blob/site/.travis.yml">excaliburjs.com&rsquo;s Travis configuration</a> to see how we use <a href="http://typedoc.io">TypeDoc</a> to generate documentation for the latest version of <code>master</code>.</p>
]]></content>
  </entry>
  
</feed>
