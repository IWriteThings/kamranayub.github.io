<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | Kamranicus]]></title>
  <link href="http://kamranicus.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://kamranicus.com/"/>
  <updated>2016-02-22T05:51:15+00:00</updated>
  <id>http://kamranicus.com/</id>
  <author>
    <name><![CDATA[Kamran]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using Typewriter to Strongly-Type Your Client-Side Models and Services]]></title>
    <link href="http://kamranicus.com/blog/2016/02/04/typewriter/"/>
    <updated>2016-02-04T02:08:00+00:00</updated>
    <id>http://kamranicus.com/blog/2016/02/04/typewriter</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve recently discovered <a href="http://frhagn.github.io/Typewriter/index.html">Typewriter for Visual Studio</a>, a T4-style code-generator specifically meant for generating Typescript files. I&rsquo;ve been using it since in all my projects, at work and at home. It&rsquo;s just <strong>so</strong> good. Let me explain what Typewriter does and why it&rsquo;s so awesome.</p>

<!-- more -->


<h2>Setting the stage</h2>

<p>It&rsquo;s 2016. The web app you&rsquo;re working on is a mix of Javascript, C#, and controllers for MVC or Web API. Your solution looks something like this:</p>

<p><img src="https://cloud.githubusercontent.com/assets/563819/12835031/1f2c4cfc-cb72-11e5-8f99-d6b3a4af3e83.png" alt="Folder structure" /></p>

<p>You&rsquo;ve got a standard folder structure with a MVC controller and API controller. You want to leverage a client-side library to make it easier to have a dynamic and responsive interface, let&rsquo;s say <a href="http://knockoutjs.com">Knockout.js</a>. You start creating a Knockout view model and you want to bind it to your view. What do you do now at this point for binding the initial data to your view?</p>

<p>Do you&hellip;</p>

<ol>
<li>Serialize the server model into JSON and pass it into your Knockout view model manually</li>
<li>Don&rsquo;t even bother and fetch the data via AJAX when the page loads</li>
</ol>


<p>In either case, you&rsquo;re left with a realization: <strong>I need to pass in my server model so I can use it in my client-side code.</strong> You&rsquo;re left doing something like this:</p>

<p>```js
var TaskListViewModel = function (model) {
   var vm = {};</p>

<p>   vm.name = ko.observable(model.name);
   vm.tasks = ko.observableArray(model.tasks.map(function (t) { return TaskViewModel(t); });</p>

<p>   return vm;
};</p>

<p>$(function () {
  var vm = TaskListViewModel(window.model);</p>

<p>  ko.applyBindings(vm);
});
```</p>

<p>And then passing in your server model, serialized from JSON either via AJAX or embedded in the view:</p>

<p>```html</p>

<script>
window.model = @Html.Raw(JsonConvert.SerializeObject(Model));

// or

$(function () {
  $.getJSON('/api/tasks', function (tasks) {
    var vm = TaskListViewModel(tasks);
    
    ko.applyBindings(vm);
  });
</script>


<p>```</p>

<p>We&rsquo;ve all done something like this because no matter what approach you choose, you have to map the models <em>somewhere</em>. You could use a mapping library like <a href="http://knockoutjs.com/documentation/plugins-mapping.html">ko.mapping</a> to help. But even with help, you still have the same problem:</p>

<blockquote><p>What happens when you change your model in C#?</p></blockquote>

<p>The answer is, &ldquo;I have to go and update all the references in my client-side Javascript.&rdquo; So what do we do? We try to leave it as much alone as we can, preferring not to change things so we can avoid Happy JS Refactoring Funtime.</p>

<h2>Enter Typescript, stage left</h2>

<p>We can address one aspect of this problem using <a href="http://typescriptlang.org">Typescript</a>, the typed superset of Javascript introduced by Microsoft several years ago. My love for Typescript is <a href="http://kamranicus.com/presentations/demystifying-typescript">well-documented</a> and I encourage you to go through that presentation if you haven&rsquo;t already.</p>

<p>Here&rsquo;s one reason why I love it: we can create interfaces that strongly-type our C# models.</p>

<p>```js
interface TaskListViewModel {
  id: number;
  name: string;
  author: string;
  created: Date;
  tasks: TaskViewModel[];
}</p>

<p>interface TaskViewModel {
   order: number;
   canMarkDone: boolean;
   task: Task;
}</p>

<p>interface Task {
  text: string;
  done: boolean;
  created: Date;
  modified: Date;
}
```</p>

<p>Now I&rsquo;ve created an interface that mirrors my serialized C# model representation. So now with Typescript, <strong>anytime</strong> I use a server-side model, I can ensure I never have any problems with misspellings/refactoring or type changes (e.g. &ldquo;author&rdquo; changing from a string to a <code>User</code> model). At compile-time, Typescript will ensure my references are correct.</p>

<p>Using type information, we can strongly type our previous JS view model:</p>

<p>```js
var TaskListViewModel = function (model: TaskListViewModel) {
   var vm = {};</p>

<p>   vm.name = ko.observable<string>(model.name);
   vm.tasks = ko.observableArray<TaskViewModel>(model.tasks.map(function (t) { return TaskViewModel(t); });</p>

<p>   return vm;
};
```</p>

<p>But we still have one problem: how can we avoid the headaches when our server model changes? We <em>still</em> need to update our TS models manually.</p>

<h2>Enter Typewriter, stage right</h2>

<p><a href="http://frhagn.github.io/Typewriter/index.html">Typewriter</a> is a Visual Studio extension that does one thing and does it well: it lets you create <strong>Typescript Template</strong> files. These are <em>basically</em> T4 templates but they&rsquo;re abstracted to the point where it&rsquo;s actually <em>easy</em> to use (sorry T4). When you save your C# files, Typewriter reflects over them and will run the template and generate corresponding Typescript files. This lets you do simple things like mirror types to crazy things like&hellip; generate an entire AJAX web service.</p>

<p>So, using Typewriter, what would the template file look like to mirror our models?</p>

<p>```
namespace TypewriterBlogPost {</p>

<pre><code>$Classes(TypewriterBlogPost.Models.*)[
/**
 * Interface for: $FullName
 */
export interface $Name {
    $Properties[
    $name: $Type;]
}]
</code></pre>

<p>}
```</p>

<p>The syntax of the template file is pretty straightforward, as <a href="http://frhagn.github.io/Typewriter/pages/getting-started.html">explained in the documentation</a>. Let&rsquo;s walk through it.</p>

<p><code>
$Classes(TypewriterBlogPost.Models.*)[
</code></p>

<p>The <code>Classes</code> keyword tells Typewriter to search for all public classes in a file. In parenthesis, you can filter classes by FullName using wildcard syntax. Typewriter also supports Lambda functions to filter by a predicate:</p>

<p><code>
$Classes(x =&gt; x.FullName.Length &gt; 50)[
</code></p>

<p>The open square bracket indicates a repeated block of code of Typescript. We declare an interface since we want to add type safety, not an implementation (although you could, which you&rsquo;ll see next!). You can append another square pair for a separator string if there are > 1 items that match (i.e. multiple classes in a file, multiple properties, multiple methods).</p>

<p>Next, we list the properties using the same syntax. By the way, Typewriter has full Intellisense for all these keywords and variable names.</p>

<p><img src="https://cloud.githubusercontent.com/assets/563819/12796507/baabed5c-ca84-11e5-99bf-2079d85dabf0.png" alt="Intellisense" /></p>

<h2>Customize Knockout View Models</h2>

<p>Now that we have our models reflected and auto-syncing with our client-side code, we can do some extra fun stuff to <em>automatically generate Knockout view models.</em></p>

<p>The goal here is to auto-generate a base view model that we can then extend with custom methods, properties, and computed observables.</p>

<p>```js
${</p>

<pre><code>string KnockoutType(Property p) {
    if (p.Type.IsEnumerable) {
        return p.Type.Name.TrimEnd('[',']');
    }

    return p.Type;
}

string KnockoutValue(Property property) {
    var type = KnockoutType(property);

    if (IsEnumerableViewModel(property)) {
        return $"ko.observableArray&lt;Knockout{type}&gt;([])";
    } else if (property.Type.IsEnumerable) {
        return $"ko.observableArray&lt;{type}&gt;([])";
    }

    return $"ko.observable&lt;{type}&gt;()";
}    

bool IsEnumerableViewModel(Property p) {
    string type = KnockoutType(p);

    return p.Type.IsEnumerable &amp;&amp; type.EndsWith("ViewModel");
}
</code></pre>

<p>}
namespace TypewriterBlogPost {</p>

<pre><code>$Classes(*ViewModel)[ 
/**
 * Interface for: $FullName
 */
export interface $Name {
    $Properties[
    $name: $Type;]
}

/**
 * Knockout base view model for $FullName
 */
export class Knockout$Name {        
    $Properties[
    public $name = $KnockoutValue;]

    constructor(model: $Name) {
        this.map(model);
    }

    /**
     * Map $Name model to Knockout view model
     */
    public map(model: $Name) {
        $Properties(x =&gt; !IsEnumerableViewModel(x))[
        this.$name(model.$name);]
        $Properties(x =&gt; IsEnumerableViewModel(x))[
        this.$name(model.$name.map(this.map$Name));]
    }

    $Properties(x =&gt; IsEnumerableViewModel(x))[
    /**
     * Map $KnockoutType equivalent Knockout view model. Override to customize.
     */
    public map$Name(model: $KnockoutType) {
        return new Knockout$KnockoutType(model);
    }]

    /**
     * Returns a plain JSON object with current model properties
     */
    public getModel() {
        return {
            $Properties(x =&gt; !IsEnumerableViewModel(x))[
            $name: this.$name(),]
            $Properties(x =&gt; IsEnumerableViewModel(x))[
            $name: this.$name().map(x =&gt; x.getModel())][,]
        }
    }
}]
</code></pre>

<p>}
```</p>

<p>Oh man! This one&rsquo;s a doozy. All we&rsquo;re really doing is ensuring we recursively map KO view models for collections (we ignore non-ViewModels). We also added a couple convenient helper methods like <code>getModel()</code> that returns a JSON object with the current KO model values. <code>map$Name</code> allows us to customize how we map each collection, for example, to override what view model to use (such as a custom view model).</p>

<p>Typewriter allows you to create &ldquo;helper&rdquo; functions that you can then use in the template. We created ones for parsing out the Knockout types (trimming square brackets).</p>

<p>You might ask why prepend the name with <code>Knockout</code>? So that it won&rsquo;t conflict with the interfaces named after the view models. Since we want to pass in JSON from the server, we still need an interface that represents the server-side view model.</p>

<p>Here&rsquo;s an example of what this template will generate for <code>TaskListViewModel</code>:</p>

<p>```js
namespace TypewriterBlogPost {</p>

<pre><code>/**
 * Interface for: TypewriterBlogPost.ViewModels.TaskListViewModel
 */
export interface TaskListViewModel {

    id: number;
    name: string;
    author: string;
    created: Date;
    tasks: TaskViewModel[];
}

/**
 * Knockout base view model for TypewriterBlogPost.ViewModels.TaskListViewModel
 */
export class KnockoutTaskListViewModel {        

    public id = ko.observable&lt;number&gt;();
    public name = ko.observable&lt;string&gt;();
    public author = ko.observable&lt;string&gt;();
    public created = ko.observable&lt;Date&gt;();
    public tasks = ko.observableArray&lt;KnockoutTaskViewModel&gt;([]);

    constructor(model: TaskListViewModel) {
        this.map(model);
    }

    /**
     * Map TaskListViewModel model to Knockout view model
     */
    public map(model: TaskListViewModel) {

        this.id(model.id);
        this.name(model.name);
        this.author(model.author);
        this.created(model.created);

        this.tasks(model.tasks.map(this.mapTasks));
    }


    /**
     * Map TaskViewModel equivalent Knockout view model. Override to customize.
     */
    public mapTasks(model: TaskViewModel) {
        return new KnockoutTaskViewModel(model);
    }

    /**
     * Returns a plain JSON object with current model properties
     */
    public getModel() {
        return {

            id: this.id(),
            name: this.name(),
            author: this.author(),
            created: this.created(),

            tasks: this.tasks().map(x =&gt; x.getModel())
        }
    }
}
</code></pre>

<p>}
```</p>

<p>Awesome? You bet! So how would I use this in practice? I would just <code>extend</code> the auto-generated code with my custom code!</p>

<p>```js
namespace TypewriterBlogPost {</p>

<pre><code>export class ViewModel extends KnockoutTaskListViewModel {

    constructor(model: TaskListViewModel) {
        super(model);
    }

    addTask() {
        // todo call service
    }
}

// apply KO bindings and use JSON object from server
$(() =&gt; ko.applyBindings(new ViewModel((&lt;any&gt;window).viewModel)));
</code></pre>

<p>}
```</p>

<h2>Strongly-typing your API controllers</h2>

<p>Now that we&rsquo;ve got our view models squared away, how can we leverage Typewriter to help us with our Web API methods? Well, Typewriter comes with an awesome Web API extension that makes it easy to generate strongly-typed service classes.</p>

<p>```js
${</p>

<pre><code>using Typewriter.Extensions.WebApi;

string ReturnType(Method m) =&gt; m.Type.Name == "IHttpActionResult" ? "void" : m.Type.Name;
string ServiceName(Class c) =&gt; c.Name.Replace("Controller", "Service");
string ParentServiceName(Method m) =&gt; ServiceName((Class)m.Parent);
</code></pre>

<p>}</p>

<p>module TypewriterBlogPost {</p>

<pre><code>$Classes(:ApiController)[
export class $ServiceName {
    $Methods[

    // $HttpMethod: $Url
    public static Route$Name = ($Parameters(p =&gt; p.Type.IsPrimitive)[$name: $Type][, ]) =&gt; `$Url`;
    public static $name($Parameters[$name: $Type][, ]): JQueryPromise&lt;$ReturnType&gt; {
        return $.ajax({
            url: $ParentServiceName.Route$Name($Parameters(p =&gt; p.Type.IsPrimitive)[$name][, ]),
            type: '$HttpMethod',
            data: $RequestData
        });
    }]
}]
</code></pre>

<p>}
```</p>

<p>So, let&rsquo;s break it down:</p>

<ol>
<li>Include the WebApi extensions</li>
<li>Create some helper methods to rename the controllers and provide the right return type</li>
<li>For all classes that inherit <code>ApiController</code>

<ol>
<li>Create a service class</li>
<li>For each method:

<ol>
<li>Create a route helper function that returns a URL formatted with the right parameters</li>
<li>Create a JQuery AJAX call that sends a request to the right URL and includes the right request information</li>
</ol>
</li>
</ol>
</li>
</ol>


<p>The <code>TasksController</code> we have defined looks like this:</p>

<p>```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Web.Http;
using TypewriterBlogPost.Models;
using TypewriterBlogPost.ViewModels;</p>

<p>namespace TypewriterBlogPost.Controllers
{</p>

<pre><code>public class TasksController : ApiController
{
    private static IList&lt;TaskListViewModel&gt; _taskLists = new List&lt;TaskListViewModel&gt;()
    {
        new TaskListViewModel()
        {
            Name = "Todos",
            Author = "Kamranicus",
            Created = DateTime.Now,
            Id = 1,
            Tasks =
            {
                new TaskViewModel() { Task = new Task() { Text = "Get milk from store" } },
                new TaskViewModel() { Task = new Task() { Text = "Get deli meat", Done = true  } }
            }
        }
    };

    public IEnumerable&lt;TaskListViewModel&gt; GetAll()
    {
        return _taskLists;
    }

    public TaskListViewModel GetById(int id)
    {
        return _taskLists.First(t =&gt; t.Id == id);
    }

    public void Post(int id, Task task)
    {
        var t = GetById(id);

        t.Tasks.Add(new TaskViewModel() { Task = task });        
    }
}
</code></pre>

<p>}
```</p>

<p>A few things to note:</p>

<ol>
<li>To avoid name collisions, I use <code>getAll</code> and <code>getById</code></li>
<li>To use with Typewriter, I return simple types&mdash;using <code>HttpResponseMessage</code> won&rsquo;t allow you to strongly-type the service. However you can still be flexible with errors by throwing <code>HttpExceptions</code> and Web API will serialize your response.</li>
<li>This is terrible code and is for illustrative purposes only</li>
</ol>


<p>What gets generated is what you&rsquo;d expect:</p>

<p>```js
module TypewriterBlogPost {</p>

<pre><code>export class TasksService {


    // get: api/tasks/
    public static RouteGetAll = () =&gt; `api/tasks/`;
    public static getAll(): JQueryPromise&lt;TaskListViewModel[]&gt; {
        return $.ajax({
            url: TasksService.RouteGetAll(),
            type: 'get',
            data: null
        });
    }

    // get: api/tasks/${id}
    public static RouteGetById = (id: number) =&gt; `api/tasks/${id}`;
    public static getById(id: number): JQueryPromise&lt;TaskListViewModel&gt; {
        return $.ajax({
            url: TasksService.RouteGetById(id),
            type: 'get',
            data: null
        });
    }

    // post: api/tasks/${id}
    public static RoutePost = (id: number) =&gt; `api/tasks/${id}`;
    public static post(id: number, task: Task): JQueryPromise&lt;void&gt; {
        return $.ajax({
            url: TasksService.RoutePost(id),
            type: 'post',
            data: task
        });
    }
}
</code></pre>

<p>}
```</p>

<p>Man, <em>how sexy is that?</em> Not only have we ensured our models and view models stay in-sync, our API is also reflected on the client-side so we don&rsquo;t need to worry about hard-coding routes!</p>

<p>Now we can implement our view model method properly:</p>

<p>```js
addTask(id: number, task: Task) {
  return TasksService.post(id, task).then(</p>

<pre><code>() =&gt; toastr.success("Posted new task successfully"));
</code></pre>

<p>}
```</p>

<p>Obviously there&rsquo;s much more you can do such as automatically handling errors, customizing options, creating Angular services, etc.</p>

<h2>So, that&rsquo;s why Typewriter is awesome</h2>

<p>I&rsquo;ve walked through a simple use case of why Typewriter is super useful&mdash;as a developer I&rsquo;m always interested in ways to make my life easier and not worrying about differences between my client and server is always helpful. That&rsquo;s why I love TypeScript and why I love Typewriter. Hope you found this helpful!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Planet Wars AI Competition With C# and Excalibur.js]]></title>
    <link href="http://kamranicus.com/blog/2016/01/25/planet-wars-ai-competition-excaliburjs-csharp/"/>
    <updated>2016-01-25T18:30:00+00:00</updated>
    <id>http://kamranicus.com/blog/2016/01/25/planet-wars-ai-competition-excaliburjs-csharp</id>
    <content type="html"><![CDATA[<p><img src="https://zippy.gfycat.com/BraveBlushingImpala.gif" alt="Planet Wars" /></p>

<p>This past weekend <a href="http://twitter.com/erikonarheim">Erik</a> and I built out a <a href="https://github.com/eonarheim/planet-wars-competition">Planet Wars</a> server (written in C#) and an <a href="http://excaliburjs.com">Excalibur.js</a>-powered visualization (written in TypeScript). Planet Wars is an AI competition where you build an AI that competes against another player to control a solar system. A map consists of several planets that have different growth rates and an initial number of ships. You have to send out a &ldquo;fleet&rdquo; of ships to colonize other planets and the player who controls the most planets and has destroyed their opponent&rsquo;s ships wins the game.</p>

<p>At work we are hosting our 6th Code Camp and recently we started hosting an AI competition internally. You can find past competition agents for <a href="https://github.com/eonarheim/AntAICompetition">Ants</a> and <a href="https://github.com/eonarheim/BellTowerEscape">Elevators</a>, for example.</p>

<p>The <a href="https://github.com/eonarheim/planet-wars-competition/tree/master/PlanetWars/Scripts/game">visualization for Planet Wars</a> is fairly simple, made even simpler using the power of <a href="http://excaliburjs.com">Excalibur.js</a>, the engine we work on during our spare time. We basically just use an Excalibur timer to query the status of the game state and update the state of all the actors in the game. For moving the fleets, we just use the <a href="http://excaliburjs.com/docs/api/edge/classes/ex.actioncontext.html">Actor Action API</a>.</p>

<p>For the <a href="https://github.com/eonarheim/planet-wars-competition/tree/master/PlanetWars/Server">game server</a>, we are using a <a href="https://github.com/eonarheim/planet-wars-competition/blob/master/PlanetWars/Server/HighFrequencyTimer.cs">HighFrequencyTimer</a> to run a 30fps server and then clients just send commands via HTTP, so any kind of agent will work like Python, Perl, PowerShell, or whatever! Anything that speaks HTTP can be a client. The server runs in the context of a website so we can easily query the state using a singleton <code>GameManager</code>. This wouldn&rsquo;t work in a load-balanced environment but it doesn&rsquo;t matter since people develop agents locally and we run the simulations on one server at high-speed to produce the results. If you backed the server with a data store, you could replay games but right now there&rsquo;s only an in-memory implementation.</p>

<p>To keep the server and client models in-sync, we use <a href="http://frhagn.github.io/Typewriter/index.html">Typewriter for Visual Studio</a> which is <strong>amazing</strong> and super useful not just for syncing client/server but also generating web clients, interfaces, etc. from C# code. I plan to write a separate post on some Typewriter tips for Knockout.js and Web API.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Behind the Major Update to Keep Track of My Games]]></title>
    <link href="http://kamranicus.com/blog/2015/05/30/ktomg-update/"/>
    <updated>2015-05-30T22:13:00+00:00</updated>
    <id>http://kamranicus.com/blog/2015/05/30/ktomg-update</id>
    <content type="html"><![CDATA[<p><img src="https://cloud.githubusercontent.com/assets/563819/7899619/b3154994-072a-11e5-8da1-b9a9703a8b57.png" alt="My profile" /></p>

<p>Today I just pushed a <strong>major</strong> update to <a href="http://keeptrackofmygames.com">KTOMG</a>. <em>Psst, you should join!</em></p>

<p>You can <a href="http://blog.keeptrackofmygames.com/post/120264549011/updates-for-may-2015">reference the blog post</a> for details on features but on the technical side I&rsquo;m pretty proud because I got to implement a bunch of new tech that I&rsquo;ve been wanting to learn properly.</p>

<!-- More -->


<h2>At a glance</h2>

<p>The site is built using <a href="http://getbootstrap.com">Bootstrap</a>, <a href="http://lesscss.org">LESS</a>, and <a href="http://knockoutjs.com">Knockout.js</a>. It is totally responsive and yes, every feature is available on every view. I don&rsquo;t yet have offline mode or some more app-y things like local storage quite yet but it&rsquo;s on my to-do list. By far the hardest thing to make responsive was the list view but using Flexbox and toolbar configurations, it&rsquo;s manageable. It could always be simpler though, my work is never done.</p>

<h2>CSS3 Flexbox</h2>

<p><img src="https://cloud.githubusercontent.com/assets/563819/7899652/94500830-072c-11e5-8656-59fb097ecf36.png" alt="Lists" /></p>

<p>The list view is using <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">CSS3 Flexbox</a> with <code>display: table</code> fallback w/JavaScript. A Flexbox grid is perfect for a modern responsive app, which KTOMG is. It scales down to mobile fine (and if you don&rsquo;t have Flexbox or if the fallback fails, the worst you get is a stacked list). For different breakpoints I customize the flex basis of the items to create 1-3 column layouts. The homepage will soon use Flexbox as soon as I get to it (right now it&rsquo;s using <code>display: table</code> to maintain equal-height columns). All of the modern browsers support Flexbox and for those that don&rsquo;t, they just get a wrapping grid.</p>

<p>I also use Flexbox for any grid of games using table display as a fallback; this prevents me from needing to have fixed column sizes for different screen sizes so the games will just wrap as they need to.</p>

<p><strong>Aside:</strong> The box art image grid for the list is simply just the first four games in the list (dynamically updated, since the entire page uses Knockout) positioned using <code>background-size</code> and <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Using_multiple_backgrounds">multiple backgrounds</a>. It uses a placeholder image repeated 4 times, in case the games are missing artwork and during loading.</p>

<p>Most of the CSS3/HTML5 stuff I have fallbacks by detecting features using <a href="http://modernizr.com/">Modernizr</a>.</p>

<h2>HTML5 Drag and Drop</h2>

<p>The other cool thing Flexbox gives you is some hot drag and drop action by allowing dynamic insertion of flex items:</p>

<p><img src="https://cloud.githubusercontent.com/assets/563819/7899631/1b7db50c-072b-11e5-9977-49c7b6c3b176.gif" alt="Drag and drop" /></p>

<p>I wrote the drag and drop code in vanilla HTML5 Javascript, it wasn&rsquo;t too bad <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Drag_and_drop">using MDN as a guide</a>. The fallback if that isn&rsquo;t supported is simply toolbar icons (which really is faster anyway for moving things far).</p>

<p>I admit I haven&rsquo;t tried a browser that <em>doesn&rsquo;t</em> support Flexbox but <em>does</em> support drag/drop, so that case might still need some tweaking.</p>

<h2>Hopscotch Tutorials</h2>

<p><img src="https://cloud.githubusercontent.com/assets/563819/7899658/bda3d91e-072c-11e5-80ea-932d2f309681.png" alt="Tutorials" /></p>

<p>Since lists are pretty powerful, people might need some help remembering all the things they can do.</p>

<p>I use a modified version of <a href="http://linkedin.github.io/hopscotch">Hopscotch</a> for an introduction tutorial. I struggled at first to figure out how I wanted to do tutorials. I ended up just using a string array on every user that I fill in when they finish a tutorial, allowing for an infinite number of tutorials and everyone not seeing them by default. I keep a master list of valid tutorials on the server.</p>

<p>It&rsquo;s a simple solution that will let me add tutorials as I can make them. It took me a little finnagling, but I also got the tour working fine on small screens.</p>

<h2>Stats with Chart.js</h2>

<p><img src="https://cloud.githubusercontent.com/assets/563819/7899666/222e5d5a-072d-11e5-9328-f52ae59c9e76.png" alt="Stats" /></p>

<p>I use <a href="http://www.chartjs.org/">Chart.js</a> for profile and list stats. The API is easy to use and easy to extend, as well as being sufficiently sexy. The stats I show right now are just the tip of the iceberg. I look forward to generating some cool charts later on (especially the Radar ones for comparisons).</p>

<p>Also, I apparently really like Action/Adventure and RPGs. But I knew that already, tell me something I don&rsquo;t know! Like maybe my &ldquo;burndown&rdquo; for finishing my backlog&hellip;</p>

<h2>I&rsquo;m excited</h2>

<p>I worked on this update all month as my wife will attest. I still have <a href="ktomg.uservoice.com/">plenty</a> to do but <a href="http://kamranicus.com/blog/2015/05/21/5-things-for-6-months-abroad/">our vacation</a> is coming to an end. I don&rsquo;t think I&rsquo;ll be able to release such massive updates each month but this one definitely gets me closer to completing the vision I have. I&rsquo;m pretty excited! The updates are just in time for the big gaming conferences, if only I could get public lists out by the end of June&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Knockout.js Binding Report for Performance Tuning]]></title>
    <link href="http://kamranicus.com/blog/2015/05/25/knockout-binding-report/"/>
    <updated>2015-05-25T10:30:00+00:00</updated>
    <id>http://kamranicus.com/blog/2015/05/25/knockout-binding-report</id>
    <content type="html"><![CDATA[<p>I use a lot of <a href="http://knockoutjs.com">Knockout.js</a> on <a href="http://keeptrackofmygames.com">Keep Track of My Games</a>. I love Knockout but sometimes it makes it difficult to understand what&rsquo;s slowing my page down.</p>

<!-- More -->


<p>For the game list, there&rsquo;s a lot of binding going on because I have to bind not only the list of games but also the toolbar.</p>

<p><img src="http://41.media.tumblr.com/fefa8f95951ed13a2f4d22e758bb807b/tumblr_inline_nonu62Tr1J1qlpzxk_540.png" alt="KTOMG list" /></p>

<p>Before I deploy the newest update (shown above), I&rsquo;d prefer it if the list binding performance was better than it is now. Currently there&rsquo;s a visible block on the UI thread when returning results from the API, about 500-1000ms. <strong>This is unacceptable.</strong></p>

<p>A quick Google search did not yield anything regarding a &ldquo;real&rdquo; performance tool for Knockout. What I would love is an extension that would overlay performance statistics over the UI of my app after binding is complete. This way I could visualize and easily pinpoint what bindings are causing performance issues.</p>

<p>I&rsquo;ve made a small step towards that dream by creating a simple reporting script that outputs a &ldquo;binding report&rdquo; to the Chrome console:</p>

<p><img src="https://cloud.githubusercontent.com/assets/563819/7795861/5a10389a-02d9-11e5-9462-056fa9e4da18.png" alt="Binding report" /></p>

<p>The report displays the total duration of the binding process (which is all bindings that occur after a 500ms wait time) as well as the top binding according to total duration.</p>

<p>It also displays each binding summary in a table (<code>console.table</code>). You can drill-down by expanding the array entries underneath the table (sorted by duration).</p>

<p><img src="https://cloud.githubusercontent.com/assets/563819/7795969/8fb1c828-02da-11e5-8b81-fe88f466812e.png" alt="Drill-down" /></p>

<p>The script works by wrapping all the binding handlers (even custom ones) in a wrapper function that calculates the duration of the call to <code>init</code> or <code>update</code>. You just need to include it after your custom binding handlers and before the <code>applyBindings</code> call.</p>

<p>The script requires <a href="http://underscorejs.org">Underscore</a> and Google Chrome. Here&rsquo;s the gist:</p>

<script src="https://gist.github.com/kamranayub/65399fa247a6c182bc65.js"></script>


<p>As you can see in my own performance report, I have some work to do to fix my <code>if</code> bindings. It doesn&rsquo;t exactly pinpoint the problem binding, but it gets me a step closer to understanding what&rsquo;s going on.</p>

<p><img src="https://cloud.githubusercontent.com/assets/563819/7796086/f407dc76-02db-11e5-90e7-b89613408174.png" alt="Uh oh" /></p>

<p>Now if you&rsquo;ll execuse me, I&rsquo;ve got some work to do.</p>

<p><strong>Update:</strong> Using this little script, I was able to get down to &lt;150ms from 600-900ms (and this is a slow laptop). This is much more acceptable for a release this week!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Extending Knockout Observables to Sync With Address Bar]]></title>
    <link href="http://kamranicus.com/blog/2015/05/11/extending-knockout-with-urlsync/"/>
    <updated>2015-05-11T16:20:00+00:00</updated>
    <id>http://kamranicus.com/blog/2015/05/11/extending-knockout-with-urlsync</id>
    <content type="html"><![CDATA[<p>I made a tiny Knockout extender called <code>urlSync</code> that syncs an observable with the URL.</p>

<!-- More -->


<p>For <a href="http://keeptrackofmygames.com">Keep Track of My Games</a> I&rsquo;ve been adding filtering to the game library.
I&rsquo;m really proud of what I have, here&rsquo;s what it looks like in the UI:</p>

<p><img src="/blog/images/2015-05-11-filtering.png" alt="Filtering UI" /></p>

<p>A modal allows the user to drill down and pick what filters to apply, the modal updates to show what filters are applied and what&rsquo;s available with the current resultset.</p>

<p><img src="/blog/images/2015-05-11-filtering-modal.png" alt="Filtering Modal" /></p>

<p>When you&rsquo;re outside the modal, I show any filters being applied allowing one-click removal or toggling the filtering method between AND/OR.</p>

<p>To make it easy to serialize/deserialize filters, I created a custom filtering expression that is pretty standard around town:</p>

<pre><code>{facetName}:{facetValue},{facetValue},...|...
</code></pre>

<p>For example, representing the screenshot above, the filtering expression would be:</p>

<pre><code>Lists:6|Status:8|My+Platforms:1
</code></pre>

<p>If you muck with the expression, there shouldn&rsquo;t be any issues. Facets are validated against whatever the original unfiltered resultset is, so you cannot add arbitrary expressions&mdash;if you do, they will not show up in the server response. Strings are special because potentially they can include characters used to parse the expression, the simplest way to deal with it is by encoding them and then decoding the value.</p>

<pre><code>Tags:my%20awesome%2ctag,tag2|Status:4
</code></pre>

<p>Now, I wanted to talk about the filtering expression because it makes it really easy to do a bunch of things:</p>

<ol>
<li>Reading/writing from querystring or hash</li>
<li>Create a command textbox that can parse and autocomplete expressions</li>
<li>Allow the user to save &ldquo;views&rdquo; of their games</li>
</ol>


<p>Items 2 and 3 might be on the agenda for some later date but item 1 is required for being able to create pre-filtered routes or create links. Since the library is loaded through Knockout and Web API, we need to be able to pass any filter or parameters when the page is loaded and also keep track of what the current values are for filtering.</p>

<p>To achieve this, I created a really simple <a href="http://knockoutjs.com/documentation/extenders.html">Knockout Extender</a> called <strong>urlSync.</strong> All it does is initially load an observable from the hash (if found) or the querystring (if found). Then it observes the observable and keeps the <code>window.location.hash</code> updated.</p>

<p>This could easily be extended to use <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Manipulating_the_browser_history">HTML5 <code>pushState</code></a>, if you wished. For now, managing the hash is &ldquo;good enough&rdquo; for my use case.</p>

<p>Here is a Gist of the extender:</p>

<script src="https://gist.github.com/kamranayub/3feba45dd2da3262b872.js"></script>


<p>It depends on <a href="http://medialize.github.io/URI.js">URI.js</a> and the <a href="http://medialize.github.io/URI.js/docs.html#fragment-abuse">URI.fragmentQuery</a> component. It also uses <a href="http://underscorejs.org">Underscore.js</a>, but that&rsquo;s just because I have it in my project already.</p>

<p>It&rsquo;s really simple to use, for example here&rsquo;s a snippet from my collection view model:</p>

<p>```
// Flattened facets
ViewModel.facets = ko.observableArray([]);</p>

<p>// Selected (applied) facets
ViewModel.selectedFacets = ko.observableArray([]).extend({</p>

<pre><code>urlSync: {
    param: "filterBy",
    read: function(value) {
       return kt.utils.facetsFromString(value, ViewModel.facets);
    },
    write: kt.utils.facetsToString
}
</code></pre>

<p>});</p>

<p>// Filter AND toggle
ViewModel.filterAnd = ko.observable(false).extend({ urlSync: &ldquo;filterAnd&rdquo; });
```</p>

<p>As you can see, the extender allows you to intercept read/write so you can perform any custom transformations (e.g. filtering objects to/from string). Because we&rsquo;re deserializing from a string and because the <code>checkedValue</code> binding is by reference, I pass in the existing facets collection to my utility, in order to preserve object references when required. On initial page load, this isn&rsquo;t required as the games haven&rsquo;t been fetched from the API yet. Once they are, my fetch method updates the observables. I could also modify the way I handle binding the checkboxes but this works.</p>

<p>The <code>urlSync</code> extender will then bind the observable values to the URL like this:</p>

<pre><code>users/kamran.ayub/lists/all#?
    sortBy=Name&amp;
    filterAnd=true&amp;
    filterBy=Status%3A8%7CLists%3A6%7CMy+Platforms%3A1
</code></pre>

<p>Since the extender can also fallback to reading from the querystring, we can create URLs that filter a user&rsquo;s collection:</p>

<pre><code>users/somebody/lists/all?filterBy=Platforms:2,5,40
</code></pre>

<p>Pretty neat and now allows anyone to copy/paste the URL and preserve any needed filtering state!</p>
]]></content>
  </entry>
  
</feed>
